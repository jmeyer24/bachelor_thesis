<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB 2020b"><title>Merging of clusters in the graph data</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: 400; text-align: left;  }
.S1 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S2 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.CodeBlock { background-color: #F7F7F7; margin: 10px 0 10px 0;}
.S3 { border-left: 0.994318px solid rgb(233, 233, 233); border-right: 0.994318px solid rgb(233, 233, 233); border-top: 0.994318px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S4 { border-left: 0.994318px solid rgb(233, 233, 233); border-right: 0.994318px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S5 { border-left: 0.994318px solid rgb(233, 233, 233); border-right: 0.994318px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0.994318px solid rgb(233, 233, 233); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S6 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S7 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S8 { border-left: 0.994318px solid rgb(233, 233, 233); border-right: 0.994318px solid rgb(233, 233, 233); border-top: 0.994318px solid rgb(233, 233, 233); border-bottom: 0.994318px solid rgb(233, 233, 233); border-radius: 4px; padding: 6px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S9 { border-left: 0.994318px solid rgb(233, 233, 233); border-right: 0.994318px solid rgb(233, 233, 233); border-top: 0.994318px solid rgb(233, 233, 233); border-bottom: 0.994318px solid rgb(233, 233, 233); border-radius: 4px 4px 0px 0px; padding: 6px 45px 4px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S10 { color: rgb(64, 64, 64); padding: 10px 0px 6px 17px; background: rgb(255, 255, 255) none repeat scroll 0% 0% / auto padding-box border-box; font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px; overflow-x: hidden; line-height: 17.234px;  }
.embeddedOutputsErrorElement {min-height: 18px; max-height: 250px; overflow: auto;}
.embeddedOutputsErrorElement.inlineElement {}
.embeddedOutputsErrorElement.rightPaneElement {}
.embeddedOutputsWarningElement{min-height: 18px; max-height: 250px; overflow: auto;}
.embeddedOutputsWarningElement.inlineElement {}
.embeddedOutputsWarningElement.rightPaneElement {}
.diagnosticMessage-wrapper {font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 12px;}
.diagnosticMessage-wrapper.diagnosticMessage-warningType {color: rgb(255,100,0);}
.diagnosticMessage-wrapper.diagnosticMessage-warningType a {color: rgb(255,100,0); text-decoration: underline;}
.diagnosticMessage-wrapper.diagnosticMessage-errorType {color: rgb(230,0,0);}
.diagnosticMessage-wrapper.diagnosticMessage-errorType a {color: rgb(230,0,0); text-decoration: underline;}
.diagnosticMessage-wrapper .diagnosticMessage-messagePart,.diagnosticMessage-wrapper .diagnosticMessage-causePart {white-space: pre-wrap;}
.diagnosticMessage-wrapper .diagnosticMessage-stackPart {white-space: pre;}
.embeddedOutputsTextElement,.embeddedOutputsVariableStringElement {white-space: pre; word-wrap: initial; min-height: 18px; max-height: 250px; overflow: auto;}
.textElement,.rtcDataTipElement .textElement {padding-top: 3px;}
.embeddedOutputsTextElement.inlineElement,.embeddedOutputsVariableStringElement.inlineElement {}
.inlineElement .textElement {}
.embeddedOutputsTextElement.rightPaneElement,.embeddedOutputsVariableStringElement.rightPaneElement {min-height: 16px;}
.rightPaneElement .textElement {padding-top: 2px; padding-left: 9px;}
.variableValue { width: 100% !important; }
.embeddedOutputsMatrixElement,.eoOutputWrapper .matrixElement {min-height: 18px; box-sizing: border-box;}
.embeddedOutputsMatrixElement .matrixElement,.eoOutputWrapper .matrixElement,.rtcDataTipElement .matrixElement {position: relative;}
.matrixElement .variableValue,.rtcDataTipElement .matrixElement .variableValue {white-space: pre; display: inline-block; vertical-align: top; overflow: hidden;}
.embeddedOutputsMatrixElement.inlineElement {}
.embeddedOutputsMatrixElement.inlineElement .topHeaderWrapper {display: none;}
.embeddedOutputsMatrixElement.inlineElement .veTable .body {padding-top: 0 !important; max-height: 100px;}
.inlineElement .matrixElement {max-height: 300px;}
.embeddedOutputsMatrixElement.rightPaneElement {}
.rightPaneElement .matrixElement,.rtcDataTipElement .matrixElement {overflow: hidden; padding-left: 9px;}
.rightPaneElement .matrixElement {margin-bottom: -1px;}
.embeddedOutputsMatrixElement .matrixElement .valueContainer,.eoOutputWrapper .matrixElement .valueContainer,.rtcDataTipElement .matrixElement .valueContainer {white-space: nowrap; margin-bottom: 3px;}
.embeddedOutputsMatrixElement .matrixElement .valueContainer .horizontalEllipsis.hide,.embeddedOutputsMatrixElement .matrixElement .verticalEllipsis.hide,.eoOutputWrapper .matrixElement .valueContainer .horizontalEllipsis.hide,.eoOutputWrapper .matrixElement .verticalEllipsis.hide,.rtcDataTipElement .matrixElement .valueContainer .horizontalEllipsis.hide,.rtcDataTipElement .matrixElement .verticalEllipsis.hide {display: none;}
.embeddedOutputsVariableMatrixElement .matrixElement .valueContainer.hideEllipses .verticalEllipsis, .embeddedOutputsVariableMatrixElement .matrixElement .valueContainer.hideEllipses .horizontalEllipsis {display:none;}
.embeddedOutputsMatrixElement .matrixElement .valueContainer .horizontalEllipsis,.eoOutputWrapper .matrixElement .valueContainer .horizontalEllipsis {margin-bottom: -3px;}
.eoOutputWrapper .embeddedOutputsVariableMatrixElement .matrixElement .valueContainer {cursor: default !important;}
.embeddedOutputsVariableElement {white-space: pre-wrap; word-wrap: break-word; min-height: 18px; max-height: 250px; overflow: auto;}
.variableElement {}
.embeddedOutputsVariableElement.inlineElement {}
.inlineElement .variableElement {}
.embeddedOutputsVariableElement.rightPaneElement {min-height: 16px;}
.rightPaneElement .variableElement {padding-top: 2px; padding-left: 9px;}
.variableNameElement {margin-bottom: 3px; display: inline-block;}
.matrixElement .horizontalEllipsis,.rtcDataTipElement .matrixElement .horizontalEllipsis {display: inline-block; margin-top: 3px; width: 30px; height: 12px; background-repeat: no-repeat; background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAJCAYAAADO1CeCAAAAJUlEQVR42mP4//8/A70xw0i29BUDFPxnAEtTW37wWDqakIa4pQDvOOG89lHX2gAAAABJRU5ErkJggg==");}
.matrixElement .verticalEllipsis,.textElement .verticalEllipsis,.rtcDataTipElement .matrixElement .verticalEllipsis,.rtcDataTipElement .textElement .verticalEllipsis {margin-left: 35px; width: 12px; height: 30px; background-repeat: no-repeat; background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAZCAYAAAAIcL+IAAAALklEQVR42mP4//8/AzGYgWyFMECMwv8QddRS+P//KyimlmcGUOFoOI6GI/UVAgDnd8Dd4+NCwgAAAABJRU5ErkJggg==");}
.S11 { border-left: 0.994318px solid rgb(233, 233, 233); border-right: 0.994318px solid rgb(233, 233, 233); border-top: 0.994318px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 6px 45px 0px 13px; line-height: 17.234px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }</style></head><body><div class = rtcContent><h1  class = 'S0'><span>Merging of clusters in the graph data</span></h1><h2  class = 'S1'><span>Intention</span></h2><div  class = 'S2'><span>In this script we want to sparsify the graph data we receive from Tristan.</span></div><div  class = 'S2'><span>In the data of the nodes we got at each spatial point a cluster of multiple nodes (around 27). The angles of the overlapping node clusters are unanimous whereas the bearings of each node differ.</span></div><h2  class = 'S1'><span>Preparations</span></h2><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>addpath(</span><span style="color: rgb(170, 4, 249);">"functions"</span><span>)</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>addpath(</span><span style="color: rgb(170, 4, 249);">"CircStat2012a"</span><span>)</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>format </span><span style="color: rgb(170, 4, 249);">shortG</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>nodes = read(</span><span style="color: rgb(170, 4, 249);">"data\small_graph_nodes.txt"</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>edges = read(</span><span style="color: rgb(170, 4, 249);">"data\small_graph_edges.txt"</span><span>);</span></span></div></div></div><div  class = 'S6'><span>Interestingely enough we got nodes with labels 0 to 1371, whereas the node with label 0 does not matter in a way other than initialize the graph as it gets build by Tristan's algorithm. </span></div><div  class = 'S2'><span>So in the small graph data we do not have n = 1372 nodes but n = 1371. This is reflected in the edges data in the way that their labels only go from 1 to 1371.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>nodes(1,:) = [];</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>edges = edges(:,[3 1 2 4 5]);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>all_nodes = nodes;</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>all_edges = edges;</span></span></div></div></div><div  class = 'S6'><span>The variable </span><span style=' font-weight: bold;'>n </span><span>describes the number of nodes in the graph. Here we go for one node for each line in our nodes graph data. </span></div><div  class = 'S2'><span>In future works we might want to cluster nodes or merge the ones that initialy lie on the same spatial coordinates. This future work is presicely what follows below. As to this, we initiate </span><span style=' font-weight: bold;'>n </span><span>only after our process of merging.</span></div><h2  class = 'S7'><span>Merging nodes</span></h2><div  class = 'S2'><span>The following </span><span style=' font-weight: bold;'>unique()</span><span> call gives the rows with the first occurences of a position vector. </span></div><div  class = 'S2'><span>Additionally, the indices for the row (in our case same as the </span><span style=' font-weight: bold;'>label </span><span>column) and clusterings (each overlaying points are the same cluster) are returned.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>[~,IA,~] = unique(nodes(:,[2 3]),</span><span style="color: rgb(170, 4, 249);">'rows'</span><span>,</span><span style="color: rgb(170, 4, 249);">'stable'</span><span>);</span></span></div></div></div><div  class = 'S6'><span>These arrays will be used to merge the edges of a cluster in a specific fashion. The remaining nodes will be called </span><span style=' font-weight: bold;'>representatives</span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span>nodes = nodes(IA,:);  </span><span style="color: rgb(2, 128, 9);">% these nodes are the representatives</span></span></div></div></div><div  class = 'S6'><span>Let's now assign </span><span style=' font-weight: bold;'>n </span><span>as the number of representatives.</span></div><div class="CodeBlock"><div class="inlineWrapper outputs"><div  class = 'S9'><span style="white-space: pre;"><span>n = size(nodes,1)</span></span></div><div  class = 'S10'><div class="inlineElement eoOutputWrapper embeddedOutputsVariableStringElement" uid="AEFD7C3F" data-scroll-top="null" data-scroll-left="null" data-width="961" data-height="35" data-hashorizontaloverflow="false" data-testid="output_0" style="max-height: 261px; width: 991.026px;"><div class="textElement"><div><span class="variableNameElement">n = </span></div><div>    50
</div></div></div></div></div></div><div  class = 'S6'><span>The following plot does show the same graph as the non-merged version, but intrinsically there are no overlapping nodes on the same spatial point. </span></div><div class="CodeBlock"><div class="inlineWrapper outputs"><div  class = 'S9'><span style="white-space: pre;"><span>plot(nodes(:,2),nodes(:,3),</span><span style="color: rgb(170, 4, 249);">"."</span><span>)</span></span></div><div  class = 'S10'><div class="inlineElement eoOutputWrapper embeddedOutputsFigure" uid="1799DC41" data-scroll-top="null" data-scroll-left="null" data-testid="output_1" style="width: 991.026px;"><div class="figureElement"><img class="figureImage figureContainingNode" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAjAAAAGkCAYAAAAv7h+nAAAgAElEQVR4AezBb2zVd/3///vnNY2HxQttXc2XGKSlhseKW8ivji6epX7KFNgFvWCWrFhwgBca19A5sguGP1nBlAuOssja7GuzuJYriGgkZmZZCQGqo9nGScmifpqn0p2zEOVnzE4XzFjHQvnl5JcmfBjMz/ywre/Tx+2WrpqZmZllTMLMzMwsYxJmZmZmGZMwMzMzy5iEmZmZWcYkzMzMzDImYWZmZpYxCTMzM7OMSZiZmZllTMLMzMwsYxJmZmZmGZMwMzMzy5iEmZmZWcYkzMzMzDImYWZmZpYxCTMzM7OMSZiZmZllTMLMzMwsYxJmZmZmGZMwMzMzy5iEmZmZWcYkzMzMzDImYWZmZpYxCTMzM7OMSZiZmZllTMLMzMwsYxJmZmZmGZOoUuVymRMnTvDKK69wI6VSiePHjzM5OYmZmZllS6IKjY2N8c1vfpMXXniB/v5+Nm7cyOzsLHOGh4fZsGEDo6OjbNu2jV27dmFmZmbZkagyV65cYfv27fzkJz+hv7+fX/7yl7z11lscO3aMitnZWfr7+xkZGWHfvn0cOXKEo0ePMjk5iZmZmWVDosqMjY3xhS98gdbWVub89re/5YEHHmDO1atXyeVyVCxatIiUEpcvX8bMzMyyIVFlpqenWbJkCU888QQrV66kpaWFn/3sZ8xJKdHb20t3dzcHDhxg48aNdHR0sHLlSm7mu9/9LpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEpKQhCQkIQlJSEISkpCEJCQhCUlIQhKSkIQkJCEJSUhCEt/97nepRokqc+7cOUZHR/nyl7/Ma6+9xs9//nN++tOf8tJLLzGnUChw++23U19fT01NDVNTU1y6dImbefXVV4kIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIKiKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCioggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoigIiKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKoiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgqIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKKiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCiCAiiAgigoggIogIIoKIICKICCKCV199lWqUyLi+vj5aWlpoaWmhra2NL37xiyxdupSOjg4qJLFmzRpeeOEFKk6cOMHZs2c5dOgQnZ2dDA0NUfHcc89hZmZm2ZDIuM7OTgYHBxkcHGT//v187nOf43opJVJKVExPT7N8+XJuu+025ixdupTz589jZmZm2ZDIuGXLlpHP58nn87S2trJ69WrK5TInT56kolwu8/vf/55vfetbVKxYsYLTp0/z+uuvU3Hx4kUKhQKtra3Yf7d161YWoq1bt7IQbd26lYVo69atLERbt25lIdq6dStWHRJV5tOf/jSDg4P86Ec/Yv369axdu5aOjg7uvfdeKpqbm9mxYwcPPfQQmzZt4v777+e+++7jwQcfxP67np4eFqKenh4Wop6eHhainp4eFqKenh4Wop6eHqw6JKrQPffcw8mTJzl8+DCFQoHu7m6u1dHRQaFQ4ODBgxQKBbZv346ZmZllR8LMzMwsYxJmZmZmGZMwMzMzy5iEmZmZWcYkzMzMzDImYWZmZpYxCTMzM7OMSZiZmZllTMLMzMwsYxJmZmZmGZMwMzMzy5iEmZmZWcYkzMzMzDImYWZmZpYxCTMzu6lSeYYthyc5NTXNzZTKM2w5PMmpqWluZs9okT2jRT7IntEie0aLmNm/ljAzs5vac6zIyJkLbDk8yc1sOfxfjJy5wMEz/y83s/tYkd3HioycucCNlMoz7D5WZPexIiNnLmBmHyxhZmY3tWnV/6GhLsfmexZzM73rGmmoy9FQm+NmNq9aTENdjvamWm6koS7H5lWLaajL0d5Uy42UyjOsfmaC1c9McDOl8gwjZy7wQUrlGUbOXOCDlMozjJy5wAcplWcYOXMBs09CwszMbqq9qZbizjy96xq5mfamWoo78/Sua+Rmhtc3U9yZp6Eux80Mr2+muDNPQ12OGzk1Nc2pqbcoTc9QKs9wI6emptlyeJIthye5mVNT02w5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" style="width: 560px;"></div></div></div></div></div><h2  class = 'S7'><span>Merging edges</span></h2><div  class = 'S2'><span>As we did merge multiple nodes to one just now we need to update the edges, namely their respective </span><span style=' font-weight: bold;'>from </span><span>and </span><span style=' font-weight: bold;'>to </span><span>nodes will be exchanged for the respective </span><span style=' font-weight: bold;'>representative</span><span>.</span></div><div  class = 'S2'><span></span></div><div  class = 'S2'><span>After trying brute force approaches, a worst case running time of order </span><span style=' font-weight: bold;'>O(n*e) with n=#nodes, e=#edges </span><span>is to be expected.</span></div><div  class = 'S2'><span>To optimize the order of magnitude we try another approach of the form ...</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S8'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% TODO</span></span></div></div></div><div  class = 'S6'><span></span></div><div  class = 'S2'><span>We build matrices for the </span><span style=' font-weight: bold;'>from</span><span> and the </span><span style=' font-weight: bold;'>to </span><span>columns with the representatives (their nodes labels are the array of </span><span style=' font-weight: bold;'>IA</span><span>). Here we check the smaller-greater relations of each edge node with each representative.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>maf = edges(:,2)' &lt; IA;</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>mat = edges(:,3)' &lt; IA;</span></span></div></div></div><div  class = 'S6'><span>With these matrices we test for the last representative that is smaller than the current </span><span style=' font-weight: bold;'>from</span><span> and </span><span style=' font-weight: bold;'>to</span><span> nodes respectively and update them edges.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">for </span><span>i = 1:size(edges,1)</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    [~,ia,~] = unique(maf(:,i),</span><span style="color: rgb(170, 4, 249);">'last'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    ia(1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    edges(i,2) = IA(ia(1));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    </span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    [~,ia,~] = unique(mat(:,i),</span><span style="color: rgb(170, 4, 249);">'last'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    edges(i,3) = IA(ia(1));</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><div  class = 'S2'><span>Due to the nature of Tristans search algorithm the updated edges do sometimes result in self loops. We do exclude these edges.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>selfloops = edges(:,2)==edges(:,3);</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>edges(selfloops,:) = [];</span></span></div></div></div><h2  class = 'S7'><span>Relabeling</span></h2><div  class = 'S2'><span>To be able to work with </span><span style=' font-weight: bold;'>edges</span><span> and </span><span style=' font-weight: bold;'>nodes</span><span> we need to renumber the labels of the nodes from 1 to </span><span style=' font-weight: bold;'>n</span><span>.</span></div><div class="CodeBlock"><div class="inlineWrapper outputs"><div  class = 'S9'><span style="white-space: pre;"><span>mapping = [(1:length(IA))' IA]</span></span></div><div  class = 'S10'><div class="inlineElement eoOutputWrapper embeddedOutputsVariableMatrixElement" uid="DFA7F18B" data-scroll-top="null" data-scroll-left="null" data-width="961" data-testid="output_2" style="width: 991.026px; white-space: normal; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;"><div class="matrixElement veSpecifier saveLoad" style="white-space: normal; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;"><div class="veVariableName variableNameElement double" style="width: 961px; white-space: normal; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;"><div class="headerElementClickToInteract" style="white-space: normal; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;"><span style="white-space: normal; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;">mapping = </span><span class="veVariableValueSummary veMetaSummary" style="white-space: normal; font-style: normal; color: rgb(179, 179, 179); font-size: 12px;">50×2</span></div></div><div class="valueContainer" data-layout="{&quot;columnWidth&quot;:40,&quot;totalColumns&quot;:&quot;2&quot;,&quot;totalRows&quot;:&quot;50&quot;,&quot;charsPerColumn&quot;:6}" style="white-space: nowrap; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;"><div class="variableValue" style="width: 82px; white-space: pre; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;">     1     1
     2    30
     3    49
     4    73
     5   103
     6   133
     7   163
     8   193
     9   223
    10   253
</div><div class="horizontalEllipsis hide" style="white-space: nowrap; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;"></div><div class="verticalEllipsis" style="white-space: nowrap; font-style: normal; color: rgb(64, 64, 64); font-size: 12px;"></div></div></div></div></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>nodes(:,1) = 1:size(nodes,1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>edges(:,1) = 1:size(edges,1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">for </span><span>i = 1:size(edges,1)</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    idx = find(edges(i,2)==mapping(:,2));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    edges(i,2) = idx;</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    </span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    idx = find(edges(i,3)==mapping(:,2));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    edges(i,3) = idx;</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div></div><h2  class = 'S7'><span>Circular mean</span></h2><div  class = 'S2'><span style=' font-style: italic;'>(using code from toolbox </span><a href = "https://de.mathworks.com/matlabcentral/fileexchange/10676-circular-statistics-toolbox-directional-statistics)"><span>https://de.mathworks.com/matlabcentral/fileexchange/10676-circular-statistics-toolbox-directional-statistics)</span></a></div><div  class = 'S2'><span>The north direction is consistent over each cluster of merged nodes, thus it does not need to be changed in any way.</span></div><div  class = 'S2'><span>The bearing/vote on the other hand does vary over the merged cluster. To compensate the loss of information as good as possible be calculate for the representative the circular mean over all bearings in the respective nodes cluster.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% all representatives get circ_mean bearing</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span style="color: rgb(2, 128, 9);">% first all but last, then last too</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">for </span><span>i = 1:n-1</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>    nodes(i,4) = circ_mean(all_nodes(IA(i):IA(i+1)-1,4));</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span style="color: rgb(14, 0, 255);">end</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>nodes(end,4) = circ_mean(all_nodes(IA(n):end,4));</span></span></div></div></div><h2  class = 'S7'><span>Aftermath</span></h2><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S3'><span style="white-space: pre;"><span>clc</span></span></div></div><div class="inlineWrapper"><div  class = 'S4'><span style="white-space: pre;"><span>clearvars </span><span style="color: rgb(170, 4, 249);">-except nodes edges n</span></span></div></div><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>save </span><span style="color: rgb(170, 4, 249);">materials\merged.mat</span></span></div></div></div></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% Merging of clusters in the graph data
%% Intention
% In this script we want to sparsify the graph data we receive from Tristan.
% 
% In the data of the nodes we got at each spatial point a cluster of multiple 
% nodes (around 27). The angles of the overlapping node clusters are unanimous 
% whereas the bearings of each node differ.
%% Preparations

addpath("functions")
addpath("CircStat2012a")
format shortG

nodes = read("data\small_graph_nodes.txt");
edges = read("data\small_graph_edges.txt");
%% 
% Interestingely enough we got nodes with labels 0 to 1371, whereas the node 
% with label 0 does not matter in a way other than initialize the graph as it 
% gets build by Tristan's algorithm. 
% 
% So in the small graph data we do not have n = 1372 nodes but n = 1371. This 
% is reflected in the edges data in the way that their labels only go from 1 to 
% 1371.

nodes(1,:) = [];
edges = edges(:,[3 1 2 4 5]);
all_nodes = nodes;
all_edges = edges;
%% 
% The variable *n* describes the number of nodes in the graph. Here we go for 
% one node for each line in our nodes graph data. 
% 
% In future works we might want to cluster nodes or merge the ones that initialy 
% lie on the same spatial coordinates. This future work is presicely what follows 
% below. As to this, we initiate *n* only after our process of merging.
%% Merging nodes
% The following *unique()* call gives the rows with the first occurences of 
% a position vector. 
% 
% Additionally, the indices for the row (in our case same as the *label* column) 
% and clusterings (each overlaying points are the same cluster) are returned.

[~,IA,~] = unique(nodes(:,[2 3]),'rows','stable');
%% 
% These arrays will be used to merge the edges of a cluster in a specific fashion. 
% The remaining nodes will be called *representatives*.

nodes = nodes(IA,:);  % these nodes are the representatives
%% 
% Let's now assign *n* as the number of representatives.

n = size(nodes,1)
%% 
% The following plot does show the same graph as the non-merged version, but 
% intrinsically there are no overlapping nodes on the same spatial point. 

plot(nodes(:,2),nodes(:,3),".")
%% Merging edges
% As we did merge multiple nodes to one just now we need to update the edges, 
% namely their respective *from* and *to* nodes will be exchanged for the respective 
% *representative*.
% 
% 
% 
% After trying brute force approaches, a worst case running time of order *O(n*e) 
% with n=#nodes, e=#edges* is to be expected.
% 
% To optimize the order of magnitude we try another approach of the form ...

% TODO
%% 
% 
% 
% We build matrices for the *from* and the *to* columns with the representatives 
% (their nodes labels are the array of *IA*). Here we check the smaller-greater 
% relations of each edge node with each representative.

maf = edges(:,2)' < IA;
mat = edges(:,3)' < IA;
%% 
% With these matrices we test for the last representative that is smaller than 
% the current *from* and *to* nodes respectively and update them edges.

for i = 1:size(edges,1)
    [~,ia,~] = unique(maf(:,i),'last');
    ia(1);
    edges(i,2) = IA(ia(1));
    
    [~,ia,~] = unique(mat(:,i),'last');
    edges(i,3) = IA(ia(1));
end
%% 
% Due to the nature of Tristans search algorithm the updated edges do sometimes 
% result in self loops. We do exclude these edges.

selfloops = edges(:,2)==edges(:,3);
edges(selfloops,:) = [];
%% Relabeling
% To be able to work with *edges* and *nodes* we need to renumber the labels 
% of the nodes from 1 to *n*.

mapping = [(1:length(IA))' IA]
nodes(:,1) = 1:size(nodes,1);
edges(:,1) = 1:size(edges,1);
for i = 1:size(edges,1)
    idx = find(edges(i,2)==mapping(:,2));
    edges(i,2) = idx;
    
    idx = find(edges(i,3)==mapping(:,2));
    edges(i,3) = idx;
end
%% Circular mean
% _(using code from toolbox_ <https://de.mathworks.com/matlabcentral/fileexchange/10676-circular-statistics-toolbox-directional-statistics) 
% https://de.mathworks.com/matlabcentral/fileexchange/10676-circular-statistics-toolbox-directional-statistics)>
% 
% The north direction is consistent over each cluster of merged nodes, thus 
% it does not need to be changed in any way.
% 
% The bearing/vote on the other hand does vary over the merged cluster. To compensate 
% the loss of information as good as possible be calculate for the representative 
% the circular mean over all bearings in the respective nodes cluster.

% all representatives get circ_mean bearing
% first all but last, then last too
for i = 1:n-1
    nodes(i,4) = circ_mean(all_nodes(IA(i):IA(i+1)-1,4));
end
nodes(end,4) = circ_mean(all_nodes(IA(n):end,4));
%% Aftermath

clc
clearvars -except nodes edges n
save materials\merged.mat
##### SOURCE END #####
--></body></html>